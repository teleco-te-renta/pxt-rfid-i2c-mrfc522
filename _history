{"entries":[{"timestamp":1765582477374,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":159,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":212,"length1":41,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":239,"length1":79,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// aquí va el archivo \"tests\"; esto no se compilará cuando este paquete se utilice como una extensión.\n"},{"type":"added","filename":"custom.ts","value":"/**\n * RFID MFRC522 I2C driver\n */\n//% weight=20 color=\"#AA278D\" icon=\"\\uf2bb\" block=\"RFID I2C MFRC522\"\nnamespace mfrc522 {\n    let _instance: MFRC522 | null = null;\n\n    /**\n     * Initialize the RFID MFRC522 module\n     * @param address I2C address, default 0x28\n     */\n    //% block=\"initialize RFID MFRC522 at address %address\"\n    //% address.defl=0x28\n    //% weight=90\n    export function init(address: number = 0x28) {\n        if (!_instance) {\n            _instance = new MFRC522(address);\n        }\n        _instance.init();\n    }\n\n    /**\n     * Reads the UID of a card if detected\n     */\n    //% block=\"read RFID UID\"\n    //% weight=80\n    export function readUID(): string {\n        if (!_instance) return \"\";\n\n        // Request card\n        let result = _instance.request(MFRC522.PICC_REQIDL);\n        if (result.status != 0) {\n            // Try requesting all if IDL failed, or just fail\n            return \"\";\n        }\n\n        // Anti-collision to get UID\n        let anti = _instance.anticoll();\n        if (anti.status == 0) {\n            // Convert UID to hex string\n            let hex = \"\";\n            for (let i = 0; i < anti.uid.length; i++) {\n                let byte = anti.uid[i];\n                if (byte < 16) hex += \"0\";\n                hex += byte.toString();\n            }\n            return hex.toUpperCase();\n        }\n        return \"\";\n    }\n\n    export class MFRC522 {\n        address: number;\n\n        // Register Definitions\n        static PCD_IDLE = 0x00;\n        static PCD_AUTHENT = 0x0E;\n        static PCD_RECEIVE = 0x08;\n        static PCD_TRANSMIT = 0x04;\n        static PCD_TRANSCEIVE = 0x0C;\n        static PCD_RESETPHASE = 0x0F;\n        static PCD_CALCCRC = 0x03;\n\n        static PICC_REQIDL = 0x26;\n        static PICC_REQALL = 0x52;\n        static PICC_ANTICOLL = 0x93;\n        static PICC_SElECTTAG = 0x93;\n        static PICC_AUTHENT1A = 0x60;\n        static PICC_AUTHENT1B = 0x61;\n        static PICC_READ = 0x30;\n        static PICC_WRITE = 0xA0;\n        static PICC_DECREMENT = 0xC0;\n        static PICC_INCREMENT = 0xC1;\n        static PICC_RESTORE = 0xC2;\n        static PICC_TRANSFER = 0xB0;\n        static PICC_HALT = 0x50;\n\n        // MFRC522 Registers\n        // Page 0: Command and Status\n        static CommandReg = 0x01;\n        static ComIEnReg = 0x02;\n        static DivIEnReg = 0x03;\n        static ComIrqReg = 0x04;\n        static DivIrqReg = 0x05;\n        static ErrorReg = 0x06;\n        static Status1Reg = 0x07;\n        static Status2Reg = 0x08;\n        static FIFODataReg = 0x09;\n        static FIFOLevelReg = 0x0A;\n        static WaterLevelReg = 0x0B;\n        static ControlReg = 0x0C;\n        static BitFramingReg = 0x0D;\n        static CollReg = 0x0E;\n\n        // Page 1: Command\n        static ModeReg = 0x11;\n        static TxModeReg = 0x12;\n        static RxModeReg = 0x13;\n        static TxControlReg = 0x14;\n        static TxASKReg = 0x15;\n        static TxSelReg = 0x16;\n        static RxSelReg = 0x17;\n        static StyleReg = 0x18; // reserved, but used in some libs\n\n        // Page 2: CFG\n        static CRCResultRegM = 0x21;\n        static CRCResultRegL = 0x22;\n        static ModeWidthReg = 0x24; // reserved\n        static RFCfgReg = 0x26;\n        static GsNReg = 0x27;\n        static CWGsPReg = 0x28;\n        static ModGsPReg = 0x29;\n        static TModeReg = 0x2A;\n        static TPrescalerReg = 0x2B;\n        static TReloadRegH = 0x2C;\n        static TReloadRegL = 0x2D;\n        static TCounterValRegH = 0x2E;\n        static TCounterValRegL = 0x2F;\n\n        constructor(address: number = 0x28) {\n            this.address = address;\n        }\n\n        /**\n         * Writes a byte to a register\n         */\n        writeRegister(reg: number, value: number) {\n            let buf = pins.createBuffer(2);\n            buf[0] = reg;\n            buf[1] = value;\n            pins.i2cWriteBuffer(this.address, buf);\n        }\n\n        /**\n         * Reads a byte from a register\n         */\n        readRegister(reg: number): number {\n            pins.i2cWriteNumber(this.address, reg, NumberFormat.UInt8BE);\n            return pins.i2cReadNumber(this.address, NumberFormat.UInt8BE);\n        }\n\n        /**\n         * Sets bits in a register\n         */\n        setRegisterBitMask(reg: number, mask: number) {\n            let tmp = this.readRegister(reg);\n            this.writeRegister(reg, tmp | mask);\n        }\n\n        /**\n         * Clears bits in a register\n         */\n        clearRegisterBitMask(reg: number, mask: number) {\n            let tmp = this.readRegister(reg);\n            this.writeRegister(reg, tmp & (~mask));\n        }\n\n        /**\n         * Initializes the MFRC522\n         */\n        init() {\n            // Soft Reset\n            this.writeRegister(MFRC522.CommandReg, MFRC522.PCD_RESETPHASE);\n            basic.pause(50);\n\n            // Timer: TPrescaler*TreloadVal/6.78MHz = 24ms\n            this.writeRegister(MFRC522.TModeReg, 0x8D); // Tauto=1; f(Timer) = 6.78MHz/TPreScaler\n            this.writeRegister(MFRC522.TPrescalerReg, 0x3E); // TModeReg[3..0] + TPrescalerReg\n            this.writeRegister(MFRC522.TReloadRegH, 0);\n            this.writeRegister(MFRC522.TReloadRegL, 30);\n\n            this.writeRegister(MFRC522.TxASKReg, 0x40); // 100%ASK\n            this.writeRegister(MFRC522.ModeReg, 0x3D); // CRC initial value 0x6363\n\n            this.antennaOn();\n        }\n\n        antennaOn() {\n            let temp = this.readRegister(MFRC522.TxControlReg);\n            if ((temp & 0x03) == 0) {\n                this.setRegisterBitMask(MFRC522.TxControlReg, 0x03);\n            }\n        }\n\n        /**\n         * Sends a command to the card and reads response\n         */\n        toCard(command: number, sendData: number[]): { status: number, data: number[], backLen: number } {\n            let status = MFRC522.Status1Reg; // Use as temporary status var, typically MI_ERR or MI_OK\n            let irqEn = 0x00;\n            let waitIRq = 0x00;\n            let lastBits = 0;\n            let n = 0;\n\n            if (command == MFRC522.PCD_AUTHENT) {\n                irqEn = 0x12;\n                waitIRq = 0x10;\n            } else if (command == MFRC522.PCD_TRANSCEIVE) {\n                irqEn = 0x77;\n                waitIRq = 0x30;\n            }\n\n            this.writeRegister(MFRC522.ComIEnReg, irqEn | 0x80);\n            this.clearRegisterBitMask(MFRC522.ComIrqReg, 0x80);\n            this.setRegisterBitMask(MFRC522.FIFOLevelReg, 0x80); // FlushBuffer\n\n            this.writeRegister(MFRC522.CommandReg, MFRC522.PCD_IDLE);\n\n            // Write data to FIFO\n            for (let i = 0; i < sendData.length; i++) {\n                this.writeRegister(MFRC522.FIFODataReg, sendData[i]);\n            }\n\n            // Execute command\n            this.writeRegister(MFRC522.CommandReg, command);\n            if (command == MFRC522.PCD_TRANSCEIVE) {\n                this.setRegisterBitMask(MFRC522.BitFramingReg, 0x80); // StartSend\n            }\n\n            // Wait for command completion\n            let i = 2000;\n            while (i > 0) {\n                n = this.readRegister(MFRC522.ComIrqReg);\n                if (n & waitIRq) {\n                    break;\n                }\n                if (n & 0x01) { // Timer interrupt\n                    break;\n                }\n                i--;\n            }\n\n            let backData: number[] = [];\n            let backLen = 0;\n\n            if (i != 0) {\n                if ((this.readRegister(MFRC522.ErrorReg) & 0x1B) == 0) {\n                    status = 0; // MI_OK\n\n                    if (n & irqEn & 0x01) {\n                        status = 1; // MI_NOTAGERR\n                    }\n\n                    if (command == MFRC522.PCD_TRANSCEIVE) {\n                        n = this.readRegister(MFRC522.FIFOLevelReg);\n                        lastBits = this.readRegister(MFRC522.ControlReg) & 0x07;\n                        if (lastBits != 0) {\n                            backLen = (n - 1) * 8 + lastBits;\n                        } else {\n                            backLen = n * 8;\n                        }\n\n                        if (n == 0) {\n                            n = 1;\n                        }\n                        if (n > 16) {\n                            n = 16;\n                        }\n\n                        for (let k = 0; k < n; k++) {\n                            backData.push(this.readRegister(MFRC522.FIFODataReg));\n                        }\n                    }\n                } else {\n                    status = 2; // MI_ERR\n                }\n            } else {\n                status = 2; // MI_ERR\n            }\n\n            return { status: status, data: backData, backLen: backLen };\n        }\n\n        /**\n         * Request card\n         */\n        request(reqMode: number): { status: number, type: number } {\n            let status = 0;\n            let bitFraming = 0x07; // TxLastBists: 7 bits\n\n            this.writeRegister(MFRC522.BitFramingReg, bitFraming);\n\n            let result = this.toCard(MFRC522.PCD_TRANSCEIVE, [reqMode]);\n\n            if ((result.status != 2) && (result.backLen == 0x10)) {\n                status = 0; // MI_OK\n            } else {\n                status = 2; // MI_ERR\n            }\n\n            return { status: status, type: result.data[0] };\n        }\n\n        /**\n         * Anti-collision detection to read UID\n         */\n        anticoll(): { status: number, uid: number[] } {\n            this.writeRegister(MFRC522.BitFramingReg, 0x00);\n\n            let result = this.toCard(MFRC522.PCD_TRANSCEIVE, [MFRC522.PICC_ANTICOLL, 0x20]);\n\n            let status = 2; // MI_ERR\n            let uid: number[] = [];\n\n            if (result.status == 0) { // MI_OK\n                // Check if we received 5 bytes (4 byte UID + 1 byte BCC)\n                if (result.data.length == 5) {\n                    // CRC check could be done here (XOR of first 4 bytes should equal 5th)\n                    let bcc = 0;\n                    for (let i = 0; i < 4; i++) {\n                        bcc ^= result.data[i];\n                        uid.push(result.data[i]);\n                    }\n                    if (bcc == result.data[4]) {\n                        status = 0;\n                    }\n                }\n            }\n\n            return { status: status, uid: uid };\n        }\n    }\n\n}\n"}]}],"snapshots":[{"timestamp":1765582477373,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"RFID i2c MRFC522\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1765582540071}